<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1430269078877">{:repl-history {:ide [], :local [&quot;(doc slurp)&quot; &quot;(slurp \&quot;~/Desktop/pride.txt\&quot;)&quot; &quot;(slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;)&quot; &quot;(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))&quot; &quot;(take 100 pride)&quot; &quot;(split pride \&quot; \&quot;)&quot; &quot;(split \&quot; \&quot; pride)&quot; &quot;(clojure.string/split \&quot; \&quot; pride)&quot; &quot;(clojure.string/split #\&quot; \&quot; pride)&quot; &quot;(clojure.string/split pride #\&quot; \&quot;)&quot; &quot;(frequencies (clojure.string/split pride #\&quot; \&quot;))&quot; &quot;(def words (frequencies (clojure.string/split pride #\&quot; \&quot;)))&quot; &quot;(sort words)&quot; &quot;(sorted #(second) words)&quot; &quot;(sort #(second) words)&quot; &quot;(sort-b second words)&quot; &quot;(sort-by second words)&quot; &quot;(reverse (sort-by second words))&quot; &quot;(map first (reverse (sort-by second words)))&quot; &quot;(print\n  (map first (reverse (sort-by second words))))&quot; &quot;(partition 2 (clojure.string/split \&quot;The quick brown fox jumps over the lazy dog.\&quot;))&quot; &quot;(partition 2 (clojure.string/split \&quot;The quick brown fox jumps over the lazy dog.\&quot; #\&quot;\\s+\&quot;))&quot; &quot;(partition 2 (drop 1 (clojure.string/split \&quot;The quick brown fox jumps over the lazy dog.\&quot; #\&quot;\\s+\&quot;)))&quot; &quot;(partition 2 1 (clojure.string/split \&quot;The quick brown fox jumps over the lazy dog.\&quot; #\&quot;\\s+\&quot;))&quot; &quot;(def words (clojure.string/split pride #\&quot;\\s+\&quot;))&quot; &quot;(drop 1000 words)&quot; &quot;(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n(def words (clojure.string/split pride #\&quot;\\s+\&quot;))\n(def chunk (take 1000 (drop 1000 words)))\n(def pairs\n  (partition 2 1 chunk))\n(print pairs)&quot; &quot;(reduce (fn [dict pair] ) {} pairs)&quot; &quot;(into {} [\&quot;foo\&quot; \&quot;bar\&quot;])&quot; &quot;(into {} [\n          [\&quot;foo\&quot; \&quot;bar\&quot;]])&quot; &quot;(reduce (fn [dict pair] (into dict [pair])) {} pairs)&quot; &quot;(into {} ['(\&quot;foo\&quot; \&quot;bar\&quot;)])&quot; &quot;(reduce (fn [dict pair] (into dict [(vector pair)])) {} pairs)&quot; &quot;(reduce (fn [dict [word successor]] (assoc dict word accessor)) {} pairs)&quot; &quot;(reduce (fn [dict [word successor]] (assoc dict word successor)) {} pairs)&quot; &quot;(group-by first pairs\n          )&quot; &quot;(doc group-by)&quot; &quot;(def pair-matches (group-by first pairs))&quot; &quot;(map (second pair-matches))&quot; &quot;(map second pair-matches)&quot; &quot;(def x [(\&quot;more\&quot; \&quot;have\&quot;) (\&quot;more\&quot; \&quot;delightful!\&quot;) (\&quot;more\&quot; \&quot;fortunate,\&quot;)] [(\&quot;hear\&quot; \&quot;_that_;\&quot;)])&quot; &quot;(def x '[(\&quot;more\&quot; \&quot;have\&quot;) (\&quot;more\&quot; \&quot;delightful!\&quot;) (\&quot;more\&quot; \&quot;fortunate,\&quot;)])&quot; &quot;x&quot; &quot;(into {} (first (first x))\n      (map second x))&quot; &quot;(into {} [(first (first x))\n          (map second x)])&quot; &quot;(into '{} [(first (first x))\n          (map second x)])&quot; &quot;(doc into)&quot; &quot;(into '{} [(zip (first (first x))\n             (map second x))])&quot; &quot;(into '{} [\&quot;more\&quot; '(\&quot;foo\&quot; \&quot;bar\&quot;)])&quot; &quot;(into {} [\&quot;more\&quot; '(\&quot;foo\&quot; \&quot;bar\&quot;)])&quot; &quot;(filter #(= \&quot;books\&quot; (first %)) pairs)&quot; &quot;(filter #(= \&quot;more\&quot; (first %)) pairs)&quot; &quot;(map second (filter #(= \&quot;more\&quot; (first %)) pairs))&quot; &quot;(clojure.string/replace \&quot;This,\&quot; #\&quot;\\W+\&quot; \&quot;\&quot;)&quot; &quot;(clojure.string/replace \&quot;This, is a testx. One\&quot; #\&quot;\\W+\&quot; \&quot;\&quot;)&quot; &quot;(clojure.string/split \&quot;This, is a testx. One\&quot; #\&quot;\\W+\&quot; \&quot;\&quot;)&quot; &quot;(clojure.string/split \&quot;This, is a testx. One\&quot; #\&quot;\\W+\&quot; )&quot; &quot;(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n(def words (clojure.string/split pride #\&quot;\\W+\&quot;))\n(def distinct-words (distinct words))\n(def chunk (take 1000 (drop 1000 words)))\n(def pairs\n  (partition 2 1 chunk))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)&quot; &quot;(map (fn [word] [word (successors word)]) distinct-words)&quot; &quot;(into {} (map (fn [word] [word (successors word)]) distinct-words))&quot; &quot;((into {} (map (fn [word] [word (successors word)]) distinct-words)) \&quot;more\&quot;)&quot; &quot;((into {} (map (fn [word] [word (successors word)]) distinct-words)) \&quot;The\&quot;)&quot; &quot;((into {} (map (fn [word] [word (successors word)]) distinct-words)) \&quot;happy\&quot;)&quot; &quot;((into {} (map (fn [word] [word (successors word)]) distinct-words)) \&quot;girls\&quot;)&quot; &quot;((into {} (map (fn [word] [word (successors word)]) distinct-words)) \&quot;stared\&quot;)&quot; &quot;((into {} (map (fn [word] [word (successors word)]) distinct-words)) \&quot;convince\&quot;)&quot; &quot;(pairs)&quot; &quot;pairs&quot; &quot;(filter #(= % \&quot;convince\&quot;) pairs)&quot; &quot;(filter #(= (first %) \&quot;convince\&quot;) pairs)&quot; &quot;(filter #(= (second %) \&quot;convince\&quot;) pairs)&quot; &quot;(ns txt.core)\n\n(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n\n(def words (clojure.string/split pride #\&quot;\\W+\&quot;))\n\n(def chunk (take 1000 (drop 1000 words)))\n\n(def distinct-words (distinct chunk))\n\n(def pairs\n  (partition 2 1 chunk))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)\n\n(into {} (map (fn [word] [word (successors word)]) distinct-words))&quot; &quot;(def markov (into {} (map (fn [word] [word (successors word)]) distinct-words)))&quot; &quot;(rand-nth markov)&quot; &quot;(rand-nth (keys markov))&quot; &quot;(markov \&quot;making\&quot;)&quot; &quot;(markov \&quot;more\&quot;)&quot; &quot;(defn prejudice []\n  (let [starting-word (rand-nth (keys markov))]\n    (loop [word_a starting-word\n           limit 1000]\n      :while (&lt;= limit 0)\n      (print word_a)\n      (recur (rand-nth (markov starting-word)) (dec limit)))))&quot; &quot;\n(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n\n(def words (clojure.string/split pride #\&quot;\\W+\&quot;))\n\n(def chunk (take 1000 (drop 1000 words)))\n\n(def distinct-words (distinct chunk))\n\n(def pairs\n  (partition 2 1 chunk))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)\n\n(def markov (into {} (map (fn [word] [word (successors word)]) distinct-words)))\n\n\n(defn prejudice []\n  (let [starting-word (rand-nth (keys markov))]\n    (loop [word_a starting-word\n           limit 10]\n      :while (&lt;= limit 0)\n      (print word_a \&quot; \&quot;)\n      (recur (rand-nth (markov starting-word)) (dec limit)))))&quot; &quot;(defn prejudice []\n  (let [starting-word (rand-nth (keys markov))]\n    (loop [word_a starting-word\n           limit 10]\n      :while (&gt;= limit 0)\n      (print word_a \&quot; \&quot;)\n      (recur (rand-nth (markov starting-word)) (dec limit)))))&quot; &quot;(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n\n(def words (clojure.string/split pride #\&quot;\\W+\&quot;))\n\n(def chunk (take 1000 (drop 1000 words)))\n\n(def distinct-words (distinct chunk))\n\n(def pairs\n  (partition 2 1 chunk))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)\n\n(def markov (into {} (map (fn [word] [word (successors word)]) distinct-words)))\n\n\n(defn prejudice []\n  (let [starting-word (rand-nth (keys markov))]\n    (loop [word_a starting-word\n           limit 10]\n      :while (&gt;= limit 0)\n      (print word_a \&quot; \&quot;)\n      (recur (rand-nth (markov starting-word)) (dec limit)))))&quot; &quot;(prejudice)&quot; &quot;(ns txt.core)\n\n(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n\n(def words (clojure.string/lower-case (clojure.string/split pride #\&quot;\\W+\&quot;)))\n\n(def first-thousand-words (take 1000 (drop 1000 words)))\n\n(def distinct-words (distinct first-thousand-words))\n\n(def pairs\n  (partition 2 1 first-thousand-words))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)\n\n(def markov (into {} (map (fn [word] [word (successors word)]) distinct-words)))\n\n(defn jane [starting-word]\n  (take 1000\n        (iterate\n          (fn [word-a]\n            (let [successors (seq (markov word-a))]\n              (if successors\n                (rand-nth successors)\n                (rand-nth first-thousand-words))))\n          starting-word)))\n\n(def random-jane (jane (rand-nth first-thousand-words)))\n\nrandom-jane&quot; &quot;(defn jane [starting-word]\n  (take 1000\n        (iterate\n          (fn [word-a]\n            (let [successors (seq (markov word-a))\n                  _ (print successors)]\n              (if successors\n                (rand-nth successors)\n                (rand-nth first-thousand-words))))\n          starting-word)))\n\n(def random-jane (jane (rand-nth first-thousand-words)))\n\nrandom-jane&quot; &quot;(ns txt.core)\n\n(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n\n(def words (clojure.string/lower-case (clojure.string/split pride #\&quot;\\W+\&quot;)))\n\n(def first-thousand-words (take 1000 (drop 1000 words)))\n\n(def distinct-words (distinct first-thousand-words))\n\n(def pairs\n  (partition 2 1 first-thousand-words))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)\n\n(def markov (into {} (map (fn [word] [word (successors word)]) distinct-words)))\n\n(defn jane [starting-word]\n  (take 1000\n        (iterate\n          (fn [word-a]\n            (let [successors (markov word-a)\n                  _ (print successors)]\n              (if (not (?empty successors))\n                (rand-nth successors)\n                (rand-nth first-thousand-words))))\n          starting-word)))\n\n(def random-jane (jane (rand-nth first-thousand-words)))\n\nrandom-jane&quot; &quot;(ns txt.core)\n\n(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n\n(def words (clojure.string/lower-case (clojure.string/split pride #\&quot;\\W+\&quot;)))\n\n(def first-thousand-words (take 1000 (drop 1000 words)))\n\n(def distinct-words (distinct first-thousand-words))\n\n(def pairs\n  (partition 2 1 first-thousand-words))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)\n\n(def markov (into {} (map (fn [word] [word (successors word)]) distinct-words)))\n\n(defn jane [starting-word]\n  (take 1000\n        (iterate\n          (fn [word-a]\n            (let [successors (markov word-a)\n                  _ (print \&quot;successors\&quot; successors)]\n              (if (not (?empty successors))\n                (rand-nth successors)\n                (rand-nth first-thousand-words))))\n          starting-word)))\n\n(def random-jane (jane (rand-nth first-thousand-words)))&quot; &quot;(ns txt.core)\n\n(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n\n(def words (clojure.string/lower-case (clojure.string/split pride #\&quot;\\W+\&quot;)))\n\n(def first-thousand-words (take 1000 (drop 1000 words)))\n\n(def distinct-words (distinct first-thousand-words))\n\n(def pairs\n  (partition 2 1 first-thousand-words))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)\n\n(def markov (into {} (map (fn [word] [word (successors word)]) distinct-words)))\n\n(defn jane [starting-word]\n  (take 1000\n        (iterate\n          (fn [word-a]\n            (let [successors (markov word-a)\n                  _ (print \&quot;successors\&quot; successors)]\n              (if (not (empty? successors))\n                (rand-nth successors)\n                (rand-nth first-thousand-words))))\n          starting-word)))\n\n(def random-jane (jane (rand-nth first-thousand-words)))\n\n;random-jane\n;\n;(def austen (iterate\n;       (fn [word-a]\n;         (when-let [successors (seq (markov word-a))]\n;           (rand-nth successors))) \&quot;more\&quot;))\n&quot; &quot;(ns txt.core)\n\n(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n\n(def words (clojure.string/lower-case (clojure.string/split pride #\&quot;\\W+\&quot;)))\n\n(def first-thousand-words (take 1000 (drop 1000 words)))\n\n(def distinct-words (distinct first-thousand-words))\n\n(def pairs\n  (partition 2 1 first-thousand-words))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)\n\n(def markov (into {} (map (fn [word] [word (successors word)]) distinct-words)))\n\n(defn jane [starting-word]\n  (take 1000\n        (iterate\n          (fn [word-a]\n            (let [next-word (markov word-a)\n                  _ (print \&quot;next-word\&quot; next-word)]\n              (if (not (empty? next-word))\n                (rand-nth next-word)\n                (rand-nth first-thousand-words))))\n          starting-word)))\n\n(def random-jane (jane (rand-nth first-thousand-words)))\n\n;random-jane\n;\n;(def austen (iterate\n;       (fn [word-a]\n;         (when-let [successors (seq (markov word-a))]\n;           (rand-nth successors))) \&quot;more\&quot;))\n&quot; &quot;(ns txt.core)\n\n(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n\n(def words (clojure.string/lower-case (clojure.string/split pride #\&quot;\\W+\&quot;)))\n\n(def first-thousand-words (take 1000 (drop 1000 words)))\n\n(def distinct-words (distinct first-thousand-words))\n\n(def pairs\n  (partition 2 1 first-thousand-words))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)\n\n(def markov (into {} (map (fn [word] [word (successors word)]) distinct-words)))\n\n(defn jane [starting-word]\n  (take 1000\n        (iterate\n          (fn [word-a]\n            (let [next-word (seq (markov word-a))\n                  _ (print \&quot;next-word\&quot; next-word)]\n              (if (not (nil? next-word))\n                (rand-nth next-word)\n                (rand-nth first-thousand-words))))\n          starting-word)))\n\n(def random-jane (jane (rand-nth first-thousand-words)))\n\n;random-jane\n;\n;(def austen (iterate\n;       (fn [word-a]\n;         (when-let [successors (seq (markov word-a))]\n;           (rand-nth successors))) \&quot;more\&quot;))\n&quot; &quot;(ns txt.core)\n\n(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n\n(def words (clojure.string/lower-case (clojure.string/split pride #\&quot;\\W+\&quot;)))\n\n(def first-thousand-words (take 1000 (drop 1000 words)))\n\n(def distinct-words (distinct first-thousand-words))\n\n(def pairs\n  (partition 2 1 first-thousand-words))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)\n\n(def markov (into {} (map (fn [word] [word (successors word)]) distinct-words)))\n\n(defn jane [starting-word]\n  (take 1000\n        (iterate\n          (fn [word-a]\n            (let [next-word (seq (markov word-a))\n                  _ (print \&quot;next-word\&quot; next-word)]\n              (if (not (nil? next-word))\n                (rand-nth next-word)\n                (rand-nth first-thousand-words))))\n          starting-word)))\n\n(def random-jane (jane \&quot;more\&quot;))\n\n;random-jane\n;\n;(def austen (iterate\n;       (fn [word-a]\n;         (when-let [successors (seq (markov word-a))]\n;           (rand-nth successors))) \&quot;more\&quot;))\n&quot; &quot;(ns txt.core)\n\n(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n\n(def words (clojure.string/split pride #\&quot;\\W+\&quot;))\n\n(def first-thousand-words (take 1000 (drop 1000 words)))\n\n(def distinct-words (distinct first-thousand-words))\n\n(def pairs\n  (partition 2 1 first-thousand-words))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)\n\n(def markov (into {} (map (fn [word] [word (successors word)]) distinct-words)))\n\n(defn jane [starting-word]\n  (take 1000\n        (iterate\n          (fn [word-a]\n            (let [next-word (seq (markov word-a))\n                  _ (print \&quot;next-word\&quot; next-word)]\n              (if (not (nil? next-word))\n                (rand-nth next-word)\n                (rand-nth first-thousand-words))))\n          starting-word)))\n\n(def random-jane (jane \&quot;more\&quot;))\n\n;random-jane\n;\n;(def austen (iterate\n;       (fn [word-a]\n;         (when-let [successors (seq (markov word-a))]\n;           (rand-nth successors))) \&quot;more\&quot;))\n&quot; &quot;(ns txt.core)\n\n(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n\n(def words (clojure.string/split (clojure.string/lower-case pride) #\&quot;\\W+\&quot;))\n\n(def first-thousand-words (take 1000 (drop 1000 words)))\n\n(def distinct-words (distinct first-thousand-words))\n\n(def pairs\n  (partition 2 1 first-thousand-words))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)\n\n(def markov (into {} (map (fn [word] [word (successors word)]) distinct-words)))\n\n(defn jane [starting-word]\n  (take 1000\n        (iterate\n          (fn [word-a]\n            (let [next-word (seq (markov word-a))\n                  _ (print \&quot;next-word\&quot; next-word)]\n              (if (not (nil? next-word))\n                (rand-nth next-word)\n                (rand-nth first-thousand-words))))\n          starting-word)))\n\n(def random-jane (jane \&quot;more\&quot;))\n\n;random-jane\n;\n;(def austen (iterate\n;       (fn [word-a]\n;         (when-let [successors (seq (markov word-a))]\n;           (rand-nth successors))) \&quot;more\&quot;))\n&quot; &quot;random-jane&quot; &quot;(ns txt.core)\n\n(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n\n(def words (clojure.string/split (clojure.string/lower-case pride) #\&quot;\\W+\&quot;))\n\n(def first-thousand-words (take 1000 (drop 1000 words)))\n\n(def distinct-words (distinct first-thousand-words))\n\n(def pairs\n  (partition 2 1 first-thousand-words))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)\n\n(def markov (into {} (map (fn [word] [word (successors word)]) distinct-words)))\n\n(defn jane [starting-word]\n  (take 1000\n        (iterate\n          (fn [word-a]\n            (let [next-words (seq (markov word-a))]\n              (if (not (nil? next-words))\n                (rand-nth next-words)\n                (rand-nth first-thousand-words))))\n          starting-word)))\n\n(def random-jane (jane \&quot;more\&quot;))\n\nrandom-jane\n;\n;(def austen (iterate\n;       (fn [word-a]\n;         (when-let [successors (seq (markov word-a))]\n;           (rand-nth successors))) \&quot;more\&quot;))\n&quot; &quot;(ns txt.core)\n\n(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n\n(def words (clojure.string/split (clojure.string/lower-case pride) #\&quot;\\W+\&quot;))\n\n(def first-thousand-words (take 1000 (drop 1000 words)))\n\n(def distinct-words (distinct first-thousand-words))\n\n(def pairs\n  (partition 2 1 first-thousand-words))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)\n\n(def markov (into {} (map (fn [word] [word (successors word)]) distinct-words)))\n\n(defn jane [starting-word]\n  (take 1000\n        (iterate\n          (fn [word-a]\n            (let [next-words (seq (markov word-a))]\n              (if (not (nil? next-words))\n                (rand-nth next-words)\n                (rand-nth first-thousand-words))))\n          starting-word)))\n\n(def random-jane (jane (rand-nth first-thousand-words)))\n\n(barf \&quot;/Users/adam/Desktop/prejudice.txt\&quot; (clojure.string/join \&quot; \&quot; random-jane))\n\n;\n;(def austen (iterate\n;       (fn [word-a]\n;         (when-let [successors (seq (markov word-a))]\n;           (rand-nth successors))) \&quot;more\&quot;))\n&quot; &quot;(ns txt.core)\n\n(def pride (slurp \&quot;/Users/adam/Desktop/pride.txt\&quot;))\n\n(def words (clojure.string/split (clojure.string/lower-case pride) #\&quot;\\W+\&quot;))\n\n(def first-thousand-words (take 1000 (drop 1000 words)))\n\n(def distinct-words (distinct first-thousand-words))\n\n(def pairs\n  (partition 2 1 first-thousand-words))\n(print pairs)\n\n(defn successors [word]\n  (map second (filter #(= word (first %)) pairs)))\n\n(successors \&quot;more\&quot;)\n\n(def markov (into {} (map (fn [word] [word (successors word)]) distinct-words)))\n\n(defn jane [starting-word]\n  (take 1000\n        (iterate\n          (fn [word-a]\n            (let [next-words (seq (markov word-a))]\n              (if (not (nil? next-words))\n                (rand-nth next-words)\n                (rand-nth first-thousand-words))))\n          starting-word)))\n\n(def random-jane (jane (rand-nth first-thousand-words)))\n\n(spit \&quot;/Users/adam/Desktop/prejudice.txt\&quot; (clojure.string/join \&quot; \&quot; random-jane))\n\n;\n;(def austen (iterate\n;       (fn [word-a]\n;         (when-let [successors (seq (markov word-a))]\n;           (rand-nth successors))) \&quot;more\&quot;))\n&quot;], :remote []}}</component>
</project>